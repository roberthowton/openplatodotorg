---
type Props = {
  pages: (string | null)[];
};

const ref = Astro.url.searchParams.get("ref");
const initialValue = ref ?? "";

const { pages } = Astro.props;
---

<div class="dropdown" data-lines={JSON.stringify(pages)}>
  <input
    type="text"
    id="searchInput"
    placeholder="Go to reference..."
    autocomplete="off"
    value={initialValue}
  />
  <ul id="dropdownList" class="dropdown-list"></ul>
</div>

<script>
  import { addOrUpdateUrlParam } from "../utils";

  // TypeScript interface for search results
  interface SearchResult {
    type: 'reference' | 'text';
    reference: string;
    textPreview?: string;
    matchIndex?: number;
  }

  const dropdown = document.querySelector(".dropdown") as HTMLElement;
  const searchInput = document.getElementById(
    "searchInput",
  ) as HTMLInputElement;
  const dropdownList = document.getElementById("dropdownList") as HTMLElement;

  const items: (string | null)[] = JSON.parse(dropdown?.dataset?.lines || "[]");

  // Helper function to detect which text languages are currently visible
  function getVisibleLanguages(): string[] {
    const containers = document.querySelectorAll('tei-container');
    const languages: string[] = [];

    containers.forEach((container) => {
      const element = container as HTMLElement;
      if (element.offsetParent !== null) {
        const language = element.dataset.language;
        if (language) languages.push(language);
      }
    });

    return languages;
  }

  // Helper function to extract reference from text div ID
  function extractReferenceFromId(id: string, language: string): string {
    return id.replace(`-${language}-text`, '');
  }

  // Helper function to create text preview with context around match
  function createPreview(text: string, matchIndex: number, matchLength: number): string {
    const contextBefore = 30;
    const contextAfter = 30;

    const start = Math.max(0, matchIndex - contextBefore);
    const end = Math.min(text.length, matchIndex + matchLength + contextAfter);

    let preview = text.slice(start, end).trim();

    if (start > 0) preview = '...' + preview;
    if (end < text.length) preview = preview + '...';

    return preview;
  }

  // Helper function to escape regex special characters
  function escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // Helper function to highlight search term in preview
  function highlightMatch(preview: string, searchTerm: string): string {
    const regex = new RegExp(`(${escapeRegex(searchTerm)})`, 'gi');
    return preview.replace(regex, '<mark>$1</mark>');
  }

  // Search text content in visible languages
  function searchTextContent(searchText: string): SearchResult[] {
    const textResults: SearchResult[] = [];
    const searchLower = searchText.toLowerCase();
    const MAX_TEXT_RESULTS = 50;

    const visibleLanguages = getVisibleLanguages();

    visibleLanguages.forEach(language => {
      if (textResults.length >= MAX_TEXT_RESULTS) return;

      const textDivs = document.querySelectorAll(`div[id$="-${language}-text"]`);

      textDivs.forEach((div) => {
        if (textResults.length >= MAX_TEXT_RESULTS) return;

        const textContent = div.textContent || '';
        const lowerText = textContent.toLowerCase();

        if (lowerText.includes(searchLower)) {
          const matchIndex = lowerText.indexOf(searchLower);
          const reference = extractReferenceFromId(div.id, language);
          const preview = createPreview(textContent, matchIndex, searchText.length);

          textResults.push({
            type: 'text',
            reference,
            textPreview: preview,
            matchIndex
          });
        }
      });
    });

    return textResults;
  }

  // Perform dual search: references and text content
  function performSearch(searchText: string): {
    referenceResults: SearchResult[];
    textResults: SearchResult[];
  } {
    const referenceResults: SearchResult[] = [];
    const textResults: SearchResult[] = [];

    if (!searchText) {
      return { referenceResults, textResults };
    }

    const searchLower = searchText.toLowerCase();

    // 1. Search references
    const matchingRefs = items.filter((item) =>
      item?.toLowerCase().includes(searchLower)
    );

    referenceResults.push(...matchingRefs.map(ref => ({
      type: 'reference' as const,
      reference: ref || ''
    })));

    // 2. Search text content
    textResults.push(...searchTextContent(searchText));

    return { referenceResults, textResults };
  }

  // Temporary renderer for Phase 2 testing
  function renderReferences(results: SearchResult[]): void {
    dropdownList.innerHTML = '';
    if (results.length === 0) {
      dropdownList.style.display = 'none';
      return;
    }

    dropdownList.style.display = 'block';
    results.forEach(result => {
      const li = document.createElement('li');
      li.textContent = result.reference;
      li.onclick = () => selectReference(result.reference);
      dropdownList.appendChild(li);
    });
  }

  function selectReference(value: string | null) {
    searchInput.value = value || "";
    dropdownList.style.display = "none";

    if (!value) return;

    // Find all matching text divs (Greek, English, or both)
    const selectedLines = document.querySelectorAll(
      `div[id='${value}-gr-text'], div[id='${value}-en-text']`
    );

    if (selectedLines.length > 0) {
      // Scroll to the first visible reference
      selectedLines[0].scrollIntoView({ behavior: "smooth" });

      // Highlight all visible references
      selectedLines.forEach((line) => {
        line.classList.add("highlight");
      });

      addOrUpdateUrlParam("ref", value);

      // Remove highlight from all after 2 seconds
      setTimeout(() => {
        selectedLines.forEach((line) => {
          line.classList.remove("highlight");
        });
      }, 2000);
    }
  }

  document.onreadystatechange = () => {
    if (document.readyState === "complete" && searchInput.value) {
      selectReference(searchInput.value);
    }
  };

  // Listen for input changes
  searchInput.addEventListener("input", () => {
    const searchText = searchInput.value;
    if (!searchText) {
      dropdownList.style.display = 'none';
      return;
    }
    const { referenceResults, textResults } = performSearch(searchText);
    // For now, just render references (text rendering comes in Phase 3)
    renderReferences(referenceResults);
  });
</script>

<style is:global>
  .highlight {
    background-color: yellow;
  }
</style>

<style>
  .dropdown {
    position: relative;
    width: 300px;
  }

  #searchInput {
    width: 100%;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 5px;
  }

  .dropdown-list {
    position: absolute;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 5px;
    display: none;
    list-style: none;
    padding: 0;
  }

  .dropdown-list li {
    padding: 8px;
    cursor: pointer;
  }

  .dropdown-list li:hover {
    background: #f0f0f0;
  }
</style>
